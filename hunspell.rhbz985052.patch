Index: man/hunspell.1
===================================================================
RCS file: /cvsroot/hunspell/hunspell/man/hunspell.1,v
retrieving revision 1.4
diff -u -r1.4 hunspell.1
--- man/hunspell.1	13 Jun 2013 19:13:50 -0000	1.4
+++ man/hunspell.1	25 Jul 2013 08:26:50 -0000
@@ -385,5 +385,3 @@
 see hunspell(3).
 .PP
 This manual based on Ispell's manual. See ispell(1).
-.SH BUGS
-There are some layout problems with long lines.
Index: src/tools/hunspell.cxx
===================================================================
RCS file: /cvsroot/hunspell/hunspell/src/tools/hunspell.cxx,v
retrieving revision 1.34
diff -u -r1.34 hunspell.cxx
--- src/tools/hunspell.cxx	13 Jun 2013 19:37:30 -0000	1.34
+++ src/tools/hunspell.cxx	25 Jul 2013 08:26:50 -0000
@@ -854,18 +854,19 @@
 // like mbstowcs which isn't quite correct, but close enough for western
 // text in UTF-8
 void strncpyu8(char * dest, const char * src, int begin, int n) {
-	int u8 = ((ui_enc != NULL) && (strcmp(ui_enc, "UTF-8") == 0)) ? 1 : 0;
-	int i = 0;
-	while (i < begin + n) {
-		if (i >= begin)
-		{
-			if (!*src)
-				break;
-			*dest++ = *src;
+	if (n) {
+		int u8 = ((ui_enc != NULL) && (strcmp(ui_enc, "UTF-8") == 0)) ? 1 : 0;
+		for (int i = 0; i < begin + n;) {
+			if (!*src) break; // source is at it's end
+			if (!u8 || (*src & 0xc0) != 0x80) i++; // new character
+			if(i > begin){ // copy char (w/ utf-8 bytes)
+				*dest++ = *src++;
+				while(u8 && (*src & 0xc0) == 0x80) *dest++ = *src++;
+			}else{ // skip char (w/ utf-8 bytes)
+				++src;
+				while(u8 && (*src & 0xc0) == 0x80) ++src;
+			}
 		}
-		if (!u8 || (*src & 0xc0) != 0x80)
-			i++;
-		++src;
 	}
 	*dest = '\0';
 }
@@ -902,8 +903,6 @@
 		expand_tab(lines[i], chenc(parser->get_prevline(i), io_enc, ui_enc), MAXLNLEN);
 	}
 
-	int prevline = 0;
-
 	strncpy(line, parser->get_prevline(0), parser->get_tokenpos());
         line[parser->get_tokenpos()] = '\0';
 	int tokenbeg = expand_tab(line2, chenc(line, io_enc, ui_enc), MAXLNLEN);
@@ -912,10 +911,13 @@
         line[parser->get_tokenpos() + strlen(token)] = '\0';	
 	int tokenend = expand_tab(line2, chenc(line, io_enc, ui_enc), MAXLNLEN);
 
-	int rowindex = tokenend / x;
+	int rowindex = (tokenend - 1) / x;
 	int beginrow = rowindex - tokenbeg / x;
 	if (beginrow >= MAXPREVLINE) beginrow = MAXPREVLINE - 1;
 
+	int ri = rowindex;
+	int prevline = 0;
+
 	for (int i = 0; i < MAXPREVLINE; i++) {
 	        strncpyu8(line, lines[prevline], x * rowindex, x);
 		mvprintw(MAXPREVLINE + 1 - i, 0, "%s", line);
@@ -927,7 +929,7 @@
 	}
 
 	int linestartpos = tokenbeg - (tokenbeg % x);
-	strncpyu8(line, lines[0], x * rowindex + linestartpos, tokenbeg % x);
+	strncpyu8(line, lines[0], x * (ri - beginrow),  tokenbeg % x) ;
 	mvprintw(MAXPREVLINE + 1 - beginrow, 0, "%s", line);
 	attron(A_REVERSE);    
 	printw("%s", chenc(token, io_enc, ui_enc));
